<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ğŸª´ Zen Garden - Guerrilla Calm</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #0d1108;
      color: #aaff00;
      font-family: monospace;
      overflow: hidden;
      touch-action: none;
    }
    #container {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 10px;
      box-sizing: border-box;
    }
    h1 {
      margin: 0.4em 0 0.2em;
      font-size: clamp(2rem, 6vw, 3rem);
      text-shadow: 0 0 12px #aaff00;
    }
    #instructions {
      margin: 0.4em 0 1.2em;
      font-size: clamp(1rem, 4vw, 1.3rem);
      opacity: 0.9;
      text-align: center;
    }
    #canvas-wrapper {
      width: 100%;
      max-width: 90vmin;
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 35px rgba(139,69,19,0.5);
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border: 4px solid #8B4513;
      border-radius: 12px;
      touch-action: none;
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36"><circle cx="18" cy="18" r="15" fill="none" stroke="%23aaff00" stroke-width="5"/><line x1="9" y1="9" x2="27" y2="27" stroke="%23aaff00" stroke-width="7"/></svg>') 18 18, auto;
    }
    #ui {
      width: 94%;
      max-width: 640px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1.2em;
      font-size: clamp(1.2rem, 4.5vw, 1.6rem);
    }
    #rake-mode {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .mode-btn {
      padding: 10px 20px;
      background: rgba(139,69,19,0.45);
      border: 3px solid #8B4513;
      color: #ddff88;
      border-radius: 12px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: bold;
      transition: all 0.18s;
      min-width: 110px;
      text-align: center;
    }
    .mode-btn:hover {
      background: rgba(139,69,19,0.7);
      border-color: #ddff88;
    }
    .mode-btn.active {
      background: rgba(170,255,0,0.28);
      border-color: #aaff00;
      box-shadow: 0 0 18px #aaff00aa;
      transform: scale(1.08);
    }
    #controls {
      display: flex;
      gap: 20px;
    }
    #pause-btn, #reset-btn, #pattern-btn {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: rgba(139,69,19,0.4);
      border: 3px solid #8B4513;
      color: #aaff00;
      font-size: 1.9rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    #pause-btn:hover, #reset-btn:hover, #pattern-btn:hover {
      background: rgba(139,69,19,0.7);
    }
    #pattern-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.35;
      transition: opacity 1.2s;
    }
    #pattern-overlay.active { opacity: 0.6; }
    #message {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 80%;
      max-width: 520px;
      height: fit-content;
      background: rgba(0,0,0,0.82);
      padding: 2.5em 3em;
      border: 4px solid #8B4513;
      border-radius: 16px;
      text-align: center;
      color: #aaff00;
      font-size: clamp(2.2rem, 8vw, 3.6rem);
      text-shadow: 0 0 15px #aaff00;
      display: none;
      z-index: 100;
      pointer-events: none;
    }
    #timer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.4rem;
      color: #ddff88;
      background: rgba(0,0,0,0.5);
      padding: 6px 16px;
      border-radius: 12px;
      z-index: 50;
      display: none;
    }
    #version {
      position: fixed;
      bottom: 12px;
      right: 16px;
      font-size: 0.82rem;
      color: #444;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>ğŸª´ Zen Garden</h1>
    <p id="instructions">Drag to rake sand â€¢ Choose style â€¢ Try matching patterns</p>
    <div id="timer">Time: <span id="time-display">5:00</span></div>
    <div id="canvas-wrapper">
      <canvas id="garden"></canvas>
      <canvas id="pattern-overlay"></canvas>
      <div id="message">Garden in Perfect Harmony ğŸŒ¿</div>
    </div>
    <div id="ui">
      <div id="rake-mode">
        <button class="mode-btn active" data-mode="straight">Straight</button>
        <button class="mode-btn" data-mode="wavy">Wavy</button>
        <button class="mode-btn" data-mode="circle">Circle</button>
      </div>
      <div id="controls">
        <button id="pattern-btn">ğŸŒ€</button>
        <button id="pause-btn">â¸</button>
        <button id="reset-btn">â†º</button>
      </div>
    </div>
    <div id="version">v1.2.3 â€“ Persistent lines + Pattern matching score</div>
  </div>

  <script>
    // â”€â”€ DOM Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const canvas = document.getElementById('garden');
    const ctx = canvas.getContext('2d');
    const patternCanvas = document.getElementById('pattern-overlay');
    const pCtx = patternCanvas.getContext('2d');
    const messageEl = document.getElementById('message');
    const timerEl = document.getElementById('timer');
    const timeDisplay = document.getElementById('time-display');
    const pauseBtn = document.getElementById('pause-btn');
    const resetBtn = document.getElementById('reset-btn');
    const patternBtn = document.getElementById('pattern-btn');

    // â”€â”€ Game State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let width, height, cellSize;
    let sand = [];
    let rakePaths = [];              // All lines stay visible until reset
    let currentPath = [];
    let isDrawing = false;
    let currentMode = 'straight';
    let particles = [];
    let startTime = 0;
    let pausedTime = 0;
    let paused = false;
    let gameRunning = false;
    let gameOver = false; 

    const GAME_DURATION = 300; // 5 minutes in seconds

    // Pattern templates
    const patterns = [
      { name: "Concentric Circles", draw: drawConcentric },
      { name: "Spiral", draw: drawSpiral },
      { name: "Yin-Yang", draw: drawYinYang },
      { name: "Wave Field", draw: drawWaveField }
    ];
    let currentPatternIndex = -1; // -1 = no pattern active

    // â”€â”€ Audio Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    // â”€â”€ Resize & Initialize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function resize() {
      const wrapper = document.getElementById('canvas-wrapper');
      width = wrapper.clientWidth;
      height = wrapper.clientHeight;
      canvas.width = patternCanvas.width = width;
      canvas.height = patternCanvas.height = height;
      cellSize = Math.min(width, height) / 42;
      initSand();
      initParticles();
      drawEverything();
    }
    window.addEventListener('resize', resize);

    function initSand() {
      sand = [];
      const cols = Math.floor(width / cellSize) + 2;
      const rows = Math.floor(height / cellSize) + 2;
      for (let y = 0; y < rows; y++) {
        sand[y] = Array(cols).fill().map(() => ({ ripple: 0 }));
      }
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < 70; i++) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: 1 + Math.random() * 2.8,
          speed: 0.15 + Math.random() * 0.5,
          alpha: 0.25 + Math.random() * 0.45
        });
      }
    }

    // â”€â”€â”€ Pattern drawing functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function drawConcentric(ctx) {
      ctx.strokeStyle = 'rgba(180,140,100,0.7)';
      ctx.lineWidth = 3;
      const cx = width/2, cy = height/2;
      for (let r = 40; r < Math.min(width,height)*0.45; r += 35) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    function drawSpiral(ctx) {
      ctx.strokeStyle = 'rgba(180,140,100,0.65)';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      let x = width/2, y = height/2;
      let angle = 0, radius = 0;
      ctx.moveTo(x, y);
      while (radius < Math.max(width,height)) {
        angle += 0.12;
        radius += 1.8;
        x = width/2 + Math.cos(angle) * radius;
        y = height/2 + Math.sin(angle) * radius;
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawYinYang(ctx) {
      const cx = width/2, cy = height/2;
      const r = Math.min(width,height) * 0.38;
      ctx.fillStyle = 'rgba(180,140,100,0.25)';
      ctx.strokeStyle = 'rgba(180,140,100,0.8)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy-r/2, r/2, Math.PI/2, Math.PI*3/2);
      ctx.arc(cx, cy+r/2, r/2, -Math.PI/2, Math.PI/2, true);
      ctx.fill();
      ctx.stroke();
    }

    function drawWaveField(ctx) {
      ctx.strokeStyle = 'rgba(180,140,100,0.55)';
      ctx.lineWidth = 2.5;
      for (let y = 0; y < height; y += 45) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        for (let x = 0; x < width; x += 20) {
          const amp = 18 * Math.sin(x*0.018 + y*0.009);
          ctx.lineTo(x, y + amp);
        }
        ctx.stroke();
      }
    }

    function drawPattern() {
      pCtx.clearRect(0,0,width,height);
      if (currentPatternIndex >= 0) {
        const pat = patterns[currentPatternIndex];
        pat.draw(pCtx);
      }
    }

    // â”€â”€â”€ Main drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function drawEverything() {
      ctx.fillStyle = '#f5e8c7';
      ctx.fillRect(0, 0, width, height);

      // Persistent rake lines
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      rakePaths.forEach(path => {
        if (path.length < 2) return;
        ctx.strokeStyle = '#d2b48c';
        ctx.lineWidth = cellSize * 1.1;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
          const prev = path[i-1];
          const curr = path[i];
          if (path.mode === 'straight') {
            ctx.lineTo(curr.x, curr.y);
          } else if (path.mode === 'wavy') {
            const midX = (prev.x + curr.x) / 2;
            const midY = (prev.y + curr.y) / 2 + Math.sin(i * 0.8) * 14;
            ctx.quadraticCurveTo(midX, midY, curr.x, curr.y);
          } else if (path.mode === 'circle') {
            const cx = path.reduce((s,p)=>s+p.x,0) / path.length;
            const cy = path.reduce((s,p)=>s+p.y,0) / path.length;
            const r = Math.hypot(path[0].x - cx, path[0].y - cy) * 0.82;
            const finalRadius = Math.max(1, r + Math.sin(Date.now()*0.003)*8);
            ctx.arc(cx, cy, finalRadius, 0, Math.PI*2);
          }
        }
        ctx.stroke();
      });
      ctx.shadowBlur = 0;

      // Current path (live drawing)
      if (currentPath.length >= 2) {
        ctx.strokeStyle = '#d2b48c';
        ctx.lineWidth = cellSize * 1.1;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowBlur = 6;
        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
          const prev = currentPath[i-1];
          const curr = currentPath[i];
          if (currentMode === 'straight') {
            ctx.lineTo(curr.x, curr.y);
          } else if (currentMode === 'wavy') {
            const midX = (prev.x + curr.x) / 2;
            const midY = (prev.y + curr.y) / 2 + Math.sin(i * 0.8) * 14;
            ctx.quadraticCurveTo(midX, midY, curr.x, curr.y);
          } else if (currentMode === 'circle') {
            const cx = currentPath.reduce((s,p)=>s+p.x,0) / currentPath.length;
            const cy = currentPath.reduce((s,p)=>s+p.y,0) / currentPath.length;
            const r = Math.hypot(currentPath[0].x - cx, currentPath[0].y - cy) * 0.82;
            const finalRadius = Math.max(1, r + Math.sin(Date.now()*0.003)*8);
            ctx.arc(cx, cy, finalRadius, 0, Math.PI*2);
          }
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      // Ripples
      ctx.strokeStyle = 'rgba(210,180,140,0.55)';
      ctx.lineWidth = cellSize * 0.7;
      for (let y = 0; y < sand.length; y++) {
        for (let x = 0; x < sand[y].length; x++) {
          const s = sand[y][x];
          if (s.ripple > 0.02) {
            const radius = Math.max(0.5, cellSize * s.ripple * 2.4);
            ctx.globalAlpha = s.ripple * 0.85;
            ctx.beginPath();
            ctx.arc(x * cellSize, y * cellSize, radius, 0, Math.PI*2);
            ctx.stroke();
            s.ripple *= 0.975;
          }
        }
      }
      ctx.globalAlpha = 1;

      drawParticles();
      drawPattern();
    }

    function drawParticles() {
      ctx.fillStyle = 'rgba(245,230,200,0.65)';
      particles.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillRect(p.x, p.y, p.size, p.size * 0.22);
      });
      ctx.globalAlpha = 1;
    }

    function updateParticles(delta) {
      particles.forEach(p => {
        p.x += p.speed * delta * 0.05;
        if (p.x > width + 20) {
          p.x = -20;
          p.y = Math.random() * height;
        }
      });
    }

    // â”€â”€â”€ Pattern Matching Score â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function calculateMatchScore() {
      if (currentPatternIndex < 0) return 0;

      // Simple pixel comparison between rake canvas and pattern overlay
      const rakeData = ctx.getImageData(0, 0, width, height).data;
      const patternData = pCtx.getImageData(0, 0, width, height).data;

      let matchCount = 0;
      let totalRelevantPixels = 0;

      for (let i = 0; i < rakeData.length; i += 4) {
        // Check if pattern has ink at this pixel
        if (patternData[i + 3] > 80) { // alpha threshold
          totalRelevantPixels++;
          // Check if rake has similar color/ink
          if (rakeData[i + 3] > 80) {
            matchCount++;
          }
        }
      }

      return totalRelevantPixels > 0 
        ? Math.round((matchCount / totalRelevantPixels) * 100)
        : 0;
    }

    // â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function startRake(e) {
      e.preventDefault();
      initAudio();
      isDrawing = true;
      const pos = getPos(e);
      currentPath = [{x: pos.x, y: pos.y, mode: currentMode}];
      addRipple(pos.x, pos.y);
      playRakeSound();
      drawEverything();
    }

    function moveRake(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const pos = getPos(e);
      currentPath.push({x: pos.x, y: pos.y, mode: currentMode});
      addRipple(pos.x, pos.y);
      playRakeSound();
      drawEverything();
    }

    function endRake() {
      if (isDrawing && currentPath.length > 3) {
        rakePaths.push(currentPath);
      }
      currentPath = [];
      isDrawing = false;
      stopRakeSound();
      drawEverything();
    }

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
      return {x, y};
    }

    function addRipple(x, y) {
      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);
      if (sand[row] && sand[row][col]) {
        sand[row][col].ripple = 1.3;
      }
    }

    // â”€â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let rakeOsc = null;
    let rakeGain = null;

    function playRakeSound() {
      if (!audioCtx) return;
      if (!rakeOsc) {
        rakeOsc = audioCtx.createOscillator();
        rakeGain = audioCtx.createGain();
        rakeOsc.connect(rakeGain);
        rakeGain.connect(audioCtx.destination);
        rakeOsc.type = 'sine';
        rakeOsc.frequency.value = 78;
        rakeGain.gain.value = 0;
        rakeOsc.start();
      }
      rakeGain.gain.setTargetAtTime(0.12 + Math.random()*0.08, audioCtx.currentTime, 0.03);
      rakeOsc.frequency.setTargetAtTime(70 + Math.random()*30, audioCtx.currentTime, 0.06);
    }

    function stopRakeSound() {
      if (rakeGain) {
        rakeGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
      }
    }

    // â”€â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMode = btn.dataset.mode;
      });
    });

    patternBtn.addEventListener('click', () => {
      currentPatternIndex = (currentPatternIndex + 1) % (patterns.length + 1);
      if (currentPatternIndex === patterns.length) currentPatternIndex = -1;
      patternCanvas.classList.toggle('active', currentPatternIndex >= 0);
      drawEverything();
    });

    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      if (paused) {
        pausedTime += performance.now() - startTime;
        stopRakeSound();
      } else {
        startTime = performance.now() - pausedTime;
      }
    });

    resetBtn.addEventListener('click', () => {
      rakePaths = [];
      currentPath = [];
      initSand();
      initParticles();
      startTime = performance.now();
      pausedTime = 0;
      paused = false;
      messageEl.style.display = 'none';
      timerEl.style.display = 'none';
      currentPatternIndex = -1;
      patternCanvas.classList.remove('active');
      drawEverything();
    });

    // â”€â”€â”€ Timer & Scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function updateTimer() {
      if (!gameRunning || paused || gameOver) return;

      const elapsed = Math.floor((performance.now() - startTime - pausedTime) / 1000);
      const remaining = GAME_DURATION - elapsed;

      if (remaining <= 0) {
        gameRunning = false;
        const matchScore = currentPatternIndex >= 0 ? calculateMatchScore() : 0;
        const finalText = `Garden Complete!\nTime's up\nPattern match: ${matchScore}%`;
        messageEl.innerHTML = finalText.replace(/\n/g, '<br>');
        messageEl.style.display = 'block';
        return;
      }

      const mins = Math.floor(remaining / 60);
      const secs = String(remaining % 60).padStart(2, '0');
      timeDisplay.textContent = `${mins}:${secs}`;
    }

    function calculateMatchScore() {
      if (currentPatternIndex < 0) return 0;

      const rakeData = ctx.getImageData(0, 0, width, height).data;
      const patternData = pCtx.getImageData(0, 0, width, height).data;

      let matchCount = 0;
      let totalRelevant = 0;

      for (let i = 3; i < rakeData.length; i += 4) { // check alpha channel
        if (patternData[i] > 80) {
          totalRelevant++;
          if (rakeData[i] > 80) matchCount++;
        }
      }

      return totalRelevant > 0 ? Math.round((matchCount / totalRelevant) * 100) : 0;
    }

    // â”€â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastTime = 0;
    function loop(ts) {
      if (!lastTime) lastTime = ts;
      const delta = ts - lastTime;
      lastTime = ts;

      if (gameRunning && !paused) {
        updateTimer();
        updateParticles(delta);
      }

      drawEverything();
      requestAnimationFrame(loop);
    }

    // â”€â”€â”€ Event Listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    canvas.addEventListener('mousedown', startRake);
    canvas.addEventListener('mousemove', moveRake);
    canvas.addEventListener('mouseup', endRake);
    canvas.addEventListener('mouseleave', endRake);

    canvas.addEventListener('touchstart', startRake);
    canvas.addEventListener('touchmove', moveRake);
    canvas.addEventListener('touchend', endRake);
    canvas.addEventListener('touchcancel', endRake);

    document.addEventListener('click', () => {
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      if (!gameRunning) {
        startTime = performance.now();
        gameRunning = true;
        timerEl.style.display = 'block';
      }
    }, { once: false });

    resize();
    requestAnimationFrame(loop);
  </script>
</body>
</html>

